<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"><link rel="icon" href="/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/styles/default.min.css"><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><title> | Luke's Note</title><link href="/css/app.ebea70cd.css" rel="preload" as="style"><link href="/css/chunk-vendors.bad0137f.css" rel="preload" as="style"><link href="/js/app.4d7df72c.js" rel="preload" as="script"><link href="/js/chunk-vendors.d37a4b8b.js" rel="preload" as="script"><link href="/css/chunk-vendors.bad0137f.css" rel="stylesheet"><link href="/css/app.ebea70cd.css" rel="stylesheet"><meta charset="utf-8" data-vue-meta="true"><meta property="og:image" content="https://wbluke.com/img/about.f9a09115.jpeg" data-vmid="og:image" data-vue-meta="true"><meta property="og:title" content="7-3.FENCE | Luke's Note" data-vmid="og:title" data-vue-meta="true"><meta property="og:description" content="Thank you for reading my article 🦊" data-vmid="og:description" data-vue-meta="true"></head><body><noscript><strong>We're sorry but home doesn't work properly without JavaScript enabled. Please enable it to continue.</strong></noscript><div id="app"><div id="site-title"><a href="/" class="page_title router-link-active"><h1><img id="site-logo" src="/img/favicon.4eb5b8a7.png" width="24" height="24">
        Luke's Note
      </h1></a></div><div class="menu effect"><ul><li><a href="/" class="router-link-active">About</a></li><li><a href="/blog/" class="router-link-active">Blog</a></li><li><a href="/daily/" class="">Daily</a></li></ul></div><p><div data-v-eb9ce262="" id="blog"><div data-v-eb9ce262="" id="blog-contents"><article data-v-eb9ce262=""><div data-v-eb9ce262="" class="inner-title-container"><h1 data-v-eb9ce262=""><a data-v-eb9ce262="" href="http://wbluke.com/blog/2019/01/06/7-3.FENCE/" id="inner-title">[알고리즘] 7-3. FENCE (울타리 잘라내기)</a></h1><p data-v-eb9ce262="" class="meta">2019 / 01 / 06</p></div><div data-v-eb9ce262="" id="article-content"><h1 id="알고리즘-7-3.-fence-울타리-잘라내기" style="display: none;">[알고리즘] 7-3. FENCE (울타리 잘라내기)</h1>
<h3 id="문제">문제</h3>
<hr>
<details>
<p></p><summary>문제 보기</summary><p></p>
<p><a href="https://algospot.com/judge/problem/read/FENCE">Algospot Link : FENCE</a></p>
<p><strong>문제</strong></p>
<figure>
<img src="http://algospot.com/media/judge-attachments/506874700c7251881727ee4e70a1d502/fence.png" alt="울타리 잘라내기"><figcaption>울타리 잘라내기</figcaption>
</figure>
<p>너비가 같은 N개의 나무 판자를 붙여 세운 울타리가 있습니다. 시간이 지남에 따라 판자들이 부러지거나 망가져 높이가 다 달라진 관계로 울타리를 통째로 교체하기로 했습니다. 이 때 버리는 울타리의 일부를 직사각형으로 잘라내 재활용하고 싶습니다. 그림 (b)는 (a)의 울타리에서 잘라낼 수 있는 많은 직사각형 중 가장 넓은 직사각형을 보여줍니다. 울타리를 구성하는 각 판자의 높이가 주어질 때, 잘라낼 수 있는 직사각형의 최대 크기를 계산하는 프로그램을 작성하세요. 단 (c)처럼 직사각형을 비스듬히 잘라낼 수는 없습니다.</p>
<p>판자의 너비는 모두 1이라고 가정합니다.</p>
<p><strong>입력</strong></p>
<p>첫 줄에 테스트 케이스의 개수 <code class="hljs">C (C≤50)</code>가 주어집니다. 각 테스트 케이스의 첫 줄에는 판자의 수 <code class="hljs">N (1≤N≤20000)</code>이 주어집니다. 그 다음 줄에는 N개의 정수로 왼쪽부터 각 판자의 높이가 순서대로 주어집니다. 높이는 모두 10,000 이하의 음이 아닌 정수입니다.</p>
<p><strong>출력</strong></p>
<p>각 테스트 케이스당 정수 하나를 한 줄에 출력합니다. 이 정수는 주어진 울타리에서 잘라낼 수 있는 최대 직사각형의 크기를 나타내야 합니다.</p>
<p><strong>예제 입력</strong></p>
<pre><code class="hljs">3
7
7 1 5 9 6 7 3
7
1 4 4 4 4 1 1
4
1 8 2 2</code></pre>
<p><strong>예제 출력</strong></p>
<pre><code class="hljs">20
16
8</code></pre>
</details>
<h3 id="정리">정리</h3>
<hr>
<ul>
<li><p>처음에 이 문제를 보았을 때는 분할 정복 알고리즘을 적용하기 위해 문제를 어떻게 분할해야 할지 감이 잘 오지 않았습니다. 눈에 확 띄는 구조가 아니었고, 제가 분할의 기준을 정해야했기에 막막했습니다.</p></li>
<li><p>문제의 n개 판자를 반으로 나눕니다. 그러면 우리가 찾는 최대 직사각형은 다음의 세 가지 경우 중 하나에 속하게 됩니다.</p></li>
</ul>
<pre class="markdown"><code class="hljs"><span class="hljs-bullet">1. </span>가장 큰 직사각형을 왼쪽 부분 문제에서만 잘라낼 수 있다.  
<span class="hljs-bullet">2. </span>가장 큰 직사각형을 오른쪽 부분 문제에서만 잘라낼 수 있다.  
<span class="hljs-bullet">3. </span>가장 큰 직사각형은 왼쪽 부분 문제와 오른쪽 부분 문제에 걸쳐 있다.  </code></pre>
<ul>
<li><p>이제 1번과 2번의 부분은 재귀호출을 하면 해결된다는 것이 보입니다. 관건은 3번을 처리하는 것이겠지요.</p></li>
<li><p>3번 문제의 포인트는 다음과 같습니다. 우리가 찾는 최대 직사각형은 <code class="hljs">반드시 부분 문제 경계에 있는 두 판자를 포함</code>한다는 것입니다. 두 판자를 포함하는 (너비가 2인) 최대 직사각형을 출발점으로 해서, 왼쪽 혹은 오른쪽으로 너비를 하나씩 넓혀가며 최대 직사각형을 갱신해주면 됩니다.</p></li>
<li><p>이 때 중요한 원칙은 가장 큰 사각형을 잡기 위해 왼쪽 혹은 오른쪽 판자 중 <code class="hljs">사각형의 높이를 최대화</code>할 수 있는 방향으로 판자를 선택해야한다는 것입니다. 그러니까 왼쪽과 오른쪽 판자 중에 더 높은 판자를 선택하도록 하면 되겠죠.</p></li>
<li><p>제 코드에서 아쉬운 점은, 문제를 해결하는 <code class="hljs">fenceArea</code>함수의 인자로 판자들의 높이 벡터인 <code class="hljs">fence</code>로 끌고 들어가서 처리한 것입니다. 책의 코드에서는 벡터를 통째로 끌고 들어가는 것이 아니라, 단순히 왼쪽과 오른쪽 정수 높이만을 가지고 처리해서 코드로직이 한결 깔끔했습니다. 이에 제 코드 밑에 추가로 책의 의사코드를 첨부하겠습니다. 저는 그것도 모르고 <del>벡터 분할해서 복사하고 순회하고 가운데가 어디지 어떻게 자르지 이게 무슨 변수였지 막 난리난리치다가</del> 겨우 풀기만 했습니다.ㅠ</p></li>
</ul>
<h3 id="코드">코드</h3>
<hr>
<h4 id="제-코드">제 코드</h4>
<details>
<p></p><summary>코드 보기</summary><p></p>
<p><a href="https://github.com/wbluke/Algorithm_PS/blob/master/CH07/CH07/FENCE.cpp">Github Link</a></p>
<pre class="cpp"><code class="hljs"><span class="hljs-comment">/* FENCE.cpp */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fenceArea</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;fence)</span> </span>{

    <span class="hljs-comment">//base case</span>
    <span class="hljs-keyword">if</span> (fence.size() == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> fence[<span class="hljs-number">0</span>];

    <span class="hljs-keyword">int</span> mid = fence.size() / <span class="hljs-number">2</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fenceLeft;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fenceRight;

    <span class="hljs-keyword">if</span> (fence.size() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
        fenceLeft.resize(mid);
        fenceRight.resize(mid);
    }
    <span class="hljs-keyword">else</span> {
        fenceLeft.resize(mid);
        fenceRight.resize(mid + <span class="hljs-number">1</span>);
    }
    copy(fence.begin(), fence.begin() + mid, fenceLeft.begin());
    copy(fence.begin() + mid, fence.end(), fenceRight.begin());
    

    <span class="hljs-keyword">int</span> ret = max(fenceArea(fenceLeft), fenceArea(fenceRight));

    <span class="hljs-comment">//the case when maximal rectangular cover both left side and right side </span>
    <span class="hljs-keyword">int</span> coverRec = <span class="hljs-number">2</span> * min(fence[mid - <span class="hljs-number">1</span>], fence[mid]);
    ret = max(ret, coverRec);
    <span class="hljs-keyword">int</span> left = mid - <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> right = mid;

    <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt;= fence.size() - <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">if</span> (right &lt; fence.size() - <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> || fence[left - <span class="hljs-number">1</span>] &lt;= fence[right + <span class="hljs-number">1</span>]) {
                right++;
                coverRec = (right - left + <span class="hljs-number">1</span>) * min(coverRec / (right - left), fence[right]);
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fence[left - <span class="hljs-number">1</span>] &gt; fence[right + <span class="hljs-number">1</span>]) {
                left--;
                coverRec = (right - left + <span class="hljs-number">1</span>) * min(coverRec / (right - left), fence[left]);
            }
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left &gt; <span class="hljs-number">0</span>) {
            left--;
            coverRec = (right - left + <span class="hljs-number">1</span>) * min(coverRec / (right - left), fence[left]);
        }
        ret = max(ret, coverRec);
        <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span> &amp;&amp; right == fence.size() - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{

    <span class="hljs-keyword">int</span> num;
    <span class="hljs-built_in">cin</span> &gt;&gt; num;
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>; a &lt; num; a++) {

        <span class="hljs-keyword">int</span> N;
        <span class="hljs-built_in">cin</span> &gt;&gt; N;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fence(N);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) {
            <span class="hljs-built_in">cin</span> &gt;&gt; fence[i];
        }

        <span class="hljs-built_in">cout</span> &lt;&lt; fenceArea(fence) &lt;&lt; <span class="hljs-built_in">endl</span>;

    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</details>
<h4 id="책의-의사코드">책의 의사코드</h4>
<details>
<p></p><summary>코드 보기</summary><p></p>
<pre class="cpp"><code class="hljs"><span class="hljs-comment">//각 판자의 높이를 저장하는 배열 </span>
<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; h;
<span class="hljs-comment">//h[left, right] 구간에서 찾아낼 수 있는 가장 큰 사각형의 넓이를 반환한다. </span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span>{
    <span class="hljs-comment">//base case : 판자가 하나 밖에 없는 경우 </span>
    <span class="hljs-keyword">if</span>(left == right) <span class="hljs-keyword">return</span> h[left];
    <span class="hljs-comment">//[left, mid], [mid+1, right]의 두 구간으로 문제를 분할한다. </span>
    <span class="hljs-keyword">int</span> mid = (left + right) / <span class="hljs-number">2</span>;
    <span class="hljs-comment">//분할한 문제를 각개격파 </span>
    <span class="hljs-keyword">int</span> ret = max(solve(left, mid), solve(mid+<span class="hljs-number">1</span>, right));
    <span class="hljs-comment">//부분 문제 3 : 두 부분에 모두 걸치는 사각형 중 가장 큰 것을 찾는다. </span>
    <span class="hljs-keyword">int</span> lo = mid, hi = mid + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> height = min(h[lo], h[hi]);
    <span class="hljs-comment">//[mid, mid+1]만 포함하는 너비 2인 사각형을 고려한다. </span>
    ret = max(ret, height * <span class="hljs-number">2</span>);
    <span class="hljs-comment">//사각형이 입력 전체를 덮을 때까지 확장해 나간다. </span>
    <span class="hljs-keyword">while</span>(left &lt; lo || hi &lt; right) {
        <span class="hljs-comment">//항상 높이가 더 높은 쪽으로 확장한다. </span>
        <span class="hljs-keyword">if</span>(hi &lt; right &amp;&amp; (lo == left || h[lo<span class="hljs-number">-1</span>] &lt; h[hi+<span class="hljs-number">1</span>])) {
            ++hi;
            height = min(height, h[hi]);
        }
        <span class="hljs-keyword">else</span> {
            --lo;
            height = min(height, h[lo]);
        }
        <span class="hljs-comment">//확장한 후 사각형의 넓이 </span>
        ret = max(ret, height * (hi - lo + <span class="hljs-number">1</span>));
    }
    <span class="hljs-keyword">return</span> ret;
}</code></pre>
</details>
<h3 id="문법">문법</h3>
<hr>
<ul>
<li>벡터의 복사는 보통 다음과 같이 이루어집니다 :<br>
</li>
</ul>
<pre class="cpp"><code class="hljs"><span class="hljs-built_in">vector</span>&lt;type&gt; vec;
<span class="hljs-built_in">vector</span>&lt;type&gt; dest;
dest.resize(vec.size());
copy(vec.begin(), vec.end(), dest.begin());</code></pre>
<ul>
<li><code class="hljs">v.begin()</code>과 <code class="hljs">v.end()</code>는 <code class="hljs">iterator</code>입니다.<br>
범위를 지정할 때에도 기존 벡터를 반으로 나눈다고 했을 때,</li>
</ul>
<pre class="cpp"><code class="hljs">fence.begin(), fence.begin() + mid
fence.begin() + mid, fence.end()</code></pre>
<p>이런 식으로 나누어야 둘로 나누어집니다. 그림을 그려서 생각해보면 헷갈리지 않을 것입니다.</p>
</div></article><hr data-v-eb9ce262=""></div></div></p></div><script src="/js/chunk-vendors.d37a4b8b.js"></script><script src="/js/app.4d7df72c.js"></script></body></html>