<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"><link rel="icon" href="/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/styles/default.min.css"><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><title> | Luke's Note</title><link href="/css/app.39081179.css" rel="preload" as="style"><link href="/css/chunk-vendors.bad0137f.css" rel="preload" as="style"><link href="/js/app.16a60a2e.js" rel="preload" as="script"><link href="/js/chunk-vendors.319ec894.js" rel="preload" as="script"><link href="/css/chunk-vendors.bad0137f.css" rel="stylesheet"><link href="/css/app.39081179.css" rel="stylesheet"><meta charset="utf-8" data-vue-meta="true"><meta property="og:image" content="https://wbluke.com/img/about.f9a09115.jpeg" data-vmid="og:image" data-vue-meta="true"><meta property="og:title" content="21-1.TRAVERSAL | Luke's Note" data-vmid="og:title" data-vue-meta="true"><meta property="og:description" content="Thank you for reading my article 🦊" data-vmid="og:description" data-vue-meta="true"><script type="text/javascript" async="">var disqus_shortname  = "wbluke-com";
var disqus_title      = "21-1.TRAVERSAL";
var disqus_identifier = "/2019/03/17/21-1.TRAVERSAL/";
var disqus_url        = "http://wbluke.com/blog/2019/03/17/21-1.TRAVERSAL/";
</script><script type="text/javascript" async="" src="//wbluke-com.disqus.com/embed.js"></script><link rel="preload" as="style" href="https://c.disquscdn.com/next/embed/styles/lounge.9974049bf7b0591e5d4f055cb67f3ee3.css"><link rel="preload" as="script" href="https://c.disquscdn.com/next/embed/common.bundle.880980e048a2432334f13013030456ac.js"><link rel="preload" as="script" href="https://c.disquscdn.com/next/embed/lounge.bundle.7ca5005d1897180d07d928e89d2628be.js"><link rel="preload" as="script" href="https://disqus.com/next/config.js"></head><body><noscript></noscript><div id="app"><div id="site-title"><a href="/" class="page_title router-link-active"><h1><img id="site-logo" src="/img/favicon.4eb5b8a7.png" width="24" height="24">
        Luke's Note
      </h1></a></div><div class="menu effect"><ul><li><a href="/" class="router-link-active">About</a></li><li><a href="/blog/" class="router-link-active">Blog</a></li><li><a href="/insight/" class="">Insight</a></li></ul></div><p><div data-v-16954152="" id="blog"><div data-v-16954152="" id="blog-contents"><article data-v-16954152=""><div data-v-16954152="" class="inner-title-container"><h1 data-v-16954152=""><a data-v-16954152="" href="http://wbluke.com/blog/2019/03/17/21-1.TRAVERSAL/" id="inner-title">[알고리즘] 21-1. TRAVERSAL (트리 순회 순서 변경)</a></h1><p data-v-16954152="" class="meta">2019. 03. 17. </p></div><div data-v-16954152="" id="article-content"><h1 id="알고리즘-21-1.-traversal-트리-순회-순서-변경" style="display: none;">[알고리즘] 21-1. TRAVERSAL (트리 순회 순서 변경)</h1>
<h3 id="문제">문제</h3>
<hr>
<details>
<p></p><summary>문제 보기</summary><p></p>
<p><a href="https://algospot.com/judge/problem/read/TRAVERSAL">Algospot Link : TRAVERSAL</a></p>
<p><strong>문제</strong></p>
<p>트리를 순회하는 알고리즘은 트리의 모든 노드들을 특정 순서에 맞춰 방문하지만, 트리는 배열처럼 1차원적인 구조가 아니기 때문에 단 한 가지의 당연한 순서가 존재하지 않습니다. 때문에 필요에 맞춰 순서를 정의해야 합니다. <code class="hljs">이진 트리(binary tree)</code>는 모든 노드에 왼쪽과 오른쪽, 최대 두 개의 자손이 있는 트리를 말하는데, 이진 트리의 순회 순서 중 유명한 세 가지로 <code class="hljs">전위 순회(preorder traverse)</code>, <code class="hljs">중위 순회(inorder traverse)</code> 그리고 <code class="hljs">후위 순회(postorder traverse)</code>가 있습니다. 이들은 모두 왼쪽 서브트리를 오른쪽보다 먼저 방문한다는 점에선 같지만, 트리의 루트를 언제 방문하는지가 서로 다릅니다.</p>
<p>전위 순회는 맨 처음에 트리의 루트를 방문하고, 왼쪽과 오른쪽 서브트리를 순서대로 방문합니다. 중위 순회는 왼쪽과 오른쪽 서브트리 사이에 트리의 루트를 방문하고, 후위 순회는 왼쪽과 오른쪽 서브트리를 모두 방문한 뒤에야 루트를 방문합니다.</p>
<p>다음 그림은 이진 트리의 한 예를 보여 줍니다. 이 트리를 전위 순회하면 모든 노드를 <code class="hljs">27, 16, 9, 12, 54, 36, 72</code>의 순서대로 방문하게 됩니다. 반면 중위 순회했을 때는 <code class="hljs">9, 12, 16, 27, 36, 54, 72</code>의 순서로, 후위 순회했을 때는 <code class="hljs">12, 9, 16, 36, 72, 54, 27</code>의 순서로 방문하게 되지요.</p>
<p><img src="http://algospot.com/media/judge-attachments/bbdb1ada72f7eb16c9291ed59d4761ff/traversal.png"></p>
<p>어떤 이진 트리를 전위 순회했을 때 노드들의 방문 순서와, 중위 순회했을 때 노드들의 방문 순서가 주어졌다고 합시다. 이 트리를 후위 순회했을 때 각 노드들을 어떤 순서대로 방문하게 될지 계산하는 프로그램을 작성하세요.</p>
<p><strong>입력</strong></p>
<p>입력의 첫 줄에는 테스트 케이스의 수 <code class="hljs">C (1≤C≤100)</code>가 주어집니다. 각 테스트 케이스는 세 줄로 구성되며, 첫 줄에는 트리에 포함된 노드의 수 <code class="hljs">N (1≤N≤100)</code>이 주어집니다. 그 후 두 줄에 각각 트리를 전위 순회했을 때와 중위순회 했을 때의 노드 방문 순서가 N개의 정수로 주어집니다. 각 노드는 1000 이하의 자연수로 번호 매겨져 있으며, 한 트리에서 두 노드의 번호가 같은 일은 없습니다.</p>
<p><strong>출력</strong></p>
<p>각 테스트 케이스마다, 한 줄에 해당 트리의 후위 순회했을 때 노드들의 방문 순서를 출력합니다.</p>
<p><strong>예제 입력</strong></p>
<pre><code class="hljs">2
7
27 16 9 12 54 36 72
9 12 16 27 36 54 72
6
409 479 10 838 150 441
409 10 479 150 838 441</code></pre>
<p><strong>예제 출력</strong></p>
<pre><code class="hljs">12 9 16 36 72 54 27
10 150 441 838 479 409</code></pre>
</details>
<h3 id="정리">정리</h3>
<hr>
<p>21장부터는 트리구조에 대하여 배웁니다. 트리는 구조 자체가 재귀적 성격을 갖고 있기 때문에, 트리를 활용하거나 직접 구현할 때 재귀를 자주 만나게 됩니다. 자바에서는 TreeSet, TreeMap 등의 API가 있으며, 대부분의 프로그래밍 언어의 경우 균형잡힌 트리를 만들기 위해 Red-Black 트리로 해당 자료구조가 구현되어 있습니다.</p>
<ul>
<li><p>이 문제는 트리를 배우게 되면 가장 먼저 만나게 되는 순회에 대한 문제입니다. 모든 노드를 순회하는 방법 세 가지 중, 나머지 두 가지가 주어질 때 다른 한 가지를 추측해내는 문제인데요. 이 또한 트리의 특성 상 재귀적으로 생각해 볼 수 있습니다.</p></li>
<li><p>처음 구현할 당시 주어진 배열을 직접 쪼개서 사용하는 것이 아니라 인덱스만 가지고 접근하는 구현을 시도했다가, 상당히 복잡해져서 구현을 포기했었습니다. 여기서는 직접 해당 배열을 잘라서 재귀로 구현하는 것이 가장 깔끔합니다.</p></li>
<li><p>어느 노드가 루트인지를 파악해보는 것이 핵심입니다. 주어진 예제를 관찰하면 재귀로 구현할 힌트를 얻을 수 있습니다. 주어진 트리의 루트는 전위 순회에서 가장 먼저 방문되므로 preorder[0]이 루트라는 것을 알 수 있습니다. 이를 토대로 inorder에서 루트 위치를 찾고, 그 루트를 기준으로 왼쪽에 먼저 들어온 노드들이 left 트리, 오른쪽에 후에 들어온 노드들이 right 트리임을 깨달을 수 있습니다.</p></li>
<li><p>left 트리와 right 트리를 찾으면 잘 쪼개서(?) 재귀 호출해주면 됩니다. 배열을 복사하거나 쪼갤 때 인덱스나 크기 설정에서 실수하지 않도록 주의해주면 됩니다. 저는 ArrayList에 다 넣은 후 나중에 한꺼번에 출력했는데 순회하면서 바로 출력하도록 코드를 구현하면 더 깔끔해지겠네요.</p></li>
</ul>
<h3 id="코드">코드</h3>
<hr>
<details>
<p></p><summary>코드 보기</summary><p></p>
<p><a href="https://github.com/wbluke/Algorithm_PS/blob/master/src/CH21/TRAVERSAL.java">Github Link</a></p>
<pre class="java"><code class="hljs"><span class="hljs-comment">/* TRAVERSAL.java */</span>

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TRAVERSAL</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] preorder;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] inorder;
    <span class="hljs-keyword">private</span> ArrayList&lt;Integer&gt; postorder;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">generatePostorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>{

        <span class="hljs-comment">// base case</span>
        <span class="hljs-keyword">if</span> (preorder.length == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">int</span> root = preorder[<span class="hljs-number">0</span>];

        <span class="hljs-comment">// find root node index in inorder traversal</span>
        <span class="hljs-keyword">int</span> rootIdx = -<span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.length; i++) {
            <span class="hljs-keyword">if</span> (inorder[i] == root) {
                rootIdx = i;
                <span class="hljs-keyword">break</span>;
            }
        }

        <span class="hljs-comment">// next subPreorder by left Tree : 1 ~ rootIdx + 1</span>
        <span class="hljs-comment">// next subInorder by left Tree : 0 ~ rootIdx</span>
        <span class="hljs-comment">// next subPreorder by right Tree : rootIdx + 1 ~ preorder.length</span>
        <span class="hljs-comment">// next subInorder by right Tree : rootIdx + 1 ~  ~ inorder.length</span>

        <span class="hljs-keyword">int</span>[] leftSubPreorder = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rootIdx];
        <span class="hljs-keyword">int</span>[] leftSubInorder = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[rootIdx];
        <span class="hljs-keyword">int</span>[] rightSubPreorder = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[preorder.length - rootIdx - <span class="hljs-number">1</span>];
        <span class="hljs-keyword">int</span>[] rightSubInorder = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[inorder.length - rootIdx - <span class="hljs-number">1</span>];

        System.arraycopy(preorder, <span class="hljs-number">1</span>, leftSubPreorder, <span class="hljs-number">0</span>, leftSubPreorder.length);
        System.arraycopy(inorder, <span class="hljs-number">0</span>, leftSubInorder, <span class="hljs-number">0</span>, leftSubInorder.length);
        System.arraycopy(preorder, rootIdx + <span class="hljs-number">1</span>, rightSubPreorder, <span class="hljs-number">0</span>, rightSubPreorder.length);
        System.arraycopy(inorder, rootIdx + <span class="hljs-number">1</span>, rightSubInorder, <span class="hljs-number">0</span>, rightSubInorder.length);

        <span class="hljs-comment">// left subTree</span>
        generatePostorder(leftSubPreorder, leftSubInorder);

        <span class="hljs-comment">// right subTree</span>
        generatePostorder(rightSubPreorder, rightSubInorder);

        postorder.add(root);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);

        <span class="hljs-keyword">int</span> loop = scan.nextInt();
        <span class="hljs-keyword">while</span>(loop-- &gt; <span class="hljs-number">0</span>) {
            TRAVERSAL traversal = <span class="hljs-keyword">new</span> TRAVERSAL();

            <span class="hljs-comment">// init traversals</span>
            <span class="hljs-keyword">int</span> nodes = scan.nextInt();
            traversal.preorder = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nodes];
            traversal.inorder = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nodes];
            traversal.postorder = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;nodes; i++) {
                traversal.preorder[i] = scan.nextInt();
            }
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;nodes; i++) {
                traversal.inorder[i] = scan.nextInt();
            }

            traversal.generatePostorder(traversal.preorder, traversal.inorder);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> node : traversal.postorder){
                System.out.print(node + <span class="hljs-string">" "</span>);
            }
            System.out.println();
        }
    }
}
</code></pre>
</details>
</div></article><hr data-v-16954152=""><div data-v-16954152="" id="disqus_thread"><iframe id="dsq-app9851" name="dsq-app9851" allowtransparency="true" frameborder="0" scrolling="no" tabindex="0" title="Disqus" width="100%" src="https://disqus.com/embed/comments/?base=default&amp;f=wbluke-com&amp;t_i=%2F2019%2F03%2F17%2F21-1.TRAVERSAL%2F&amp;t_u=http%3A%2F%2Fwbluke.com%2Fblog%2F2019%2F03%2F17%2F21-1.TRAVERSAL%2F&amp;t_e=21-1.TRAVERSAL&amp;t_d=%0A%20%20%20%20%20%20%20%20Luke's%20Note%0A%20%20%20%20%20%20&amp;t_t=21-1.TRAVERSAL&amp;s_o=default&amp;d_m=0#version=581fc4aed87cb2aed2487d2df585658d" style="width: 1px !important; min-width: 100% !important; border: none !important; overflow: hidden !important; height: 0px !important;"></iframe></div></div></div></p></div><script src="/js/chunk-vendors.319ec894.js"></script><script src="/js/app.16a60a2e.js"></script><iframe style="display: none;"></iframe></body></html>