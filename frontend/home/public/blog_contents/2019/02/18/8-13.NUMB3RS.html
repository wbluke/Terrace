<h1 id="알고리즘-8-13.-numb3rs-두니발-박사의-탈옥">[알고리즘] 8-13. NUMB3RS (두니발 박사의 탈옥)</h1>
<h3 id="문제">문제</h3>
<hr />
<details>
<p><summary>문제 보기</summary></p>
<p><a href="https://algospot.com/judge/problem/read/NUMB3RS">Algospot Link : NUMB3RS</a></p>
<p><strong>문제</strong><br />
위험한 살인마 두니발 박사가 감옥에서 탈출했습니다. 수배지를 붙이고 군경이 24시간 그를 추적하고 있지만 용의주도한 두니발 박사는 쉽사리 잡히지 않았습니다. d일이 지난 후에야 경찰은 프로그래밍의 천재인 찰리 교수)를 찾아왔습니다. 찰리 교수는 두니발 박사가 감옥에 남겨둔 노트를 분석해 다음과 같은 가설을 세웠습니다.</p>
<pre class="markdown"><code>* 두니발 박사는 검문을 피해 산길로만 이동한다.  
* 두니발 박사는 교도소를 탈출한 당일, 교도소와 인접한 마을 하나로 도망쳐 은신한다.
* 두니발 박사는 수색을 피하기 위해 그 후 매일 인접한 마을로 움직여 은신한다.</code></pre>
<p><img src="http://algospot.com/media/judge-attachments/298903b8a37b6938ae6915ce1cab80fd/dunibal.png" /></p>
<p>이 가설을 검증하기 위해 교도소로부터 산길로 연결된 n 개 마을들의 지도를 위 그림과 같이 구했습니다. 두니발 박사가 이 가설에 맞춰 행동하고, 움직일 수 있는 마을이 여러 개 있을 경우 그 중의 하나를 임의로 선택한다고 합시다. d 일 후에 두니발 교수가 각 마을에 있을 확률을 계산하는 프로그램을 작성하세요.</p>
<p>예를 들어 위 지도에서 3번 마을에 교도소가 있다고 합시다. 탈옥 직후 두니발 교수는 0번, 1번, 2번, 4번, 5번 중의 한 도시를 임의로 골라 도망칩니다. 따라서 1일 후에 두니발 교수가 0번 마을에 숨어 있을 확률은 1/5이고, 2일 후에 1번 마을에 숨어 있을 확률은 1/15입니다.</p>
<p><strong>입력</strong></p>
<p>입력의 첫 줄에는 테스트 케이스의 수 <code>c (1 &lt;= c &lt;= 50)</code> 가 주어집니다. 그 후 각 줄에 지도에 포함된 마을의 수 <code>n (2 &lt;= n &lt;= 50)</code> 과 탈출 후 지금까지 지난 일수 <code>d (1 &lt;= d &lt;= 100)</code>, 그리고 교도소가 있는 마을의 번호 <code>p (0 &lt;= p &lt; n)</code> 가 주어집니다. 마을은 0번부터 n-1 번까지 순서대로 번호가 매겨져 있습니다. 그 후 n 줄에는 각각 n 개의 정수로 행렬 A 가 주어집니다. i 번 행의 j 번 숫자 A[i][j] 가 1인 경우 i 번 마을에서 j 번 마을을 잇는 산길이 있다는 것을 의미하며, 0인 경우 길이 없다는 것을 의미합니다. 그 다음 줄에 확률을 계산할 마을의 수 <code>t (1 &lt;= t &lt;= n)</code> 가 주어지고, 그 다음 줄에 t 개의 정수로 확률을 계산할 마을의 번호 <code>q (0 &lt;= q &lt; n)</code> 가 주어집니다.</p>
<p>한 마을에서 다른 마을로 길이 있으면 반대 방향으로도 항상 있으며, 한 마을에서 자기 자신으로 연결되는 길은 없다고 가정해도 좋습니다.</p>
<p><strong>출력</strong></p>
<p>각 테스트 케이스마다 t 개의 실수로 각 마을에 두니발 박사가 숨어 있을 확률을 출력합니다. <code>10^(-7)</code> 이하의 절대/상대 오차가 있는 경우 정답으로 처리됩니다.</p>
<p><strong>예제 입력</strong></p>
<pre><code>2
5 2 0
0 1 1 1 0
1 0 0 0 1
1 0 0 0 0
1 0 0 0 0
0 1 0 0 0
3
0 2 4
8 2 3
0 1 1 1 0 0 0 0
1 0 0 1 0 0 0 0
1 0 0 1 0 0 0 0
1 1 1 0 1 1 0 0
0 0 0 1 0 0 1 1
0 0 0 1 0 0 0 1
0 0 0 0 1 0 0 0
0 0 0 0 1 1 0 0
4
3 1 2 6</code></pre>
<p><strong>예제 출력</strong></p>
<pre class="markdown"><code>0.83333333 0.00000000 0.16666667
0.43333333 0.06666667 0.06666667 0.06666667</code></pre>
</details>
<h3 id="정리">정리</h3>
<hr />
<p>정리하기 전에, 잠깐 여담으로 문제에 대해 얘기하자면, 왜 문제 아이디가 NUMB3RS고 제목은 두니발 박사의 탈옥인지 전혀 감이 안와서 알고스팟에 있는 링크를 찾아봤는데요.<br />
두니발 박사는 <a href="https://ko.wikipedia.org/wiki/%ED%95%9C%EB%8B%88%EB%B0%9C_%EB%A0%89%ED%84%B0">한니발</a>의 패러디였고(…) <a href="https://ko.wikipedia.org/wiki/%EB%84%98%EB%B2%84%EC%8A%A4_(%EB%93%9C%EB%9D%BC%EB%A7%88)">NUMB3RS</a>는 드라마 제목이었네요. 찰리 박사는 드라마에 나오는 천재 수학자랍니다.</p>
<ul>
<li><p>난이도 ’중’에 입력도 무지하게 많고 생각할 변수도 많아서 겁먹었었는데, 한 번에 풀어서 개인적으로 매우 뿌듯한 문제였습니다. 수학과 전공 수업이었던 그래프론 시간에 했던 것들이 직관에 상당한 도움을 주었습니다. 못 푸는 날만 있는게 아니라 이런 날도 있어야 하지 않겠습니까.</p></li>
<li>먼저 들어오는 입력이 많아서, 제 코드 기준으로 변수들을 먼저 정리해 보겠습니다.<br />
</li>
</ul>
<pre class="java"><code>int[][] villageArr : 입력으로 주어지는 마을들의 연결 정보를 담고 있는 이차원 행렬
int[] roadsOnVillage : 한 마을에 연결된 길의 개수 (그래프 이론에서의 &#39;차수&#39;)
int prison : 감옥이 있는 마을 번호
int villages : 주어지는 마을의 총 개수
int village : 마을 번호
int target : 확률을 구할 문제에서 요구하는 마을 번호</code></pre>
<ul>
<li><p>차례로 main 함수에서 입력들을 받아서 변수에 저장해줍니다. 그리고 클래스 내부에서 전역으로 필요한 것들만 속성으로 올려서 저장했습니다. 그리고 roadsOnVillage는 한 마을에 연결된 길의 개수인데, 그래프 이론에서는 ’차수’라고 부릅니다. 주어진 행렬 기준으로는 한 행의 총합이 되기 때문에, 행렬을 입력받으면서 같이 구해줍니다.</p></li>
<li><p>동적 계획법을 적용할 probCatchDunibal()은 현재 지난 날짜 days와 두니발 박사가 있을 확률을 구할 마을 번호를 인수로 받습니다. 예시 케이스를 놓고 분석을 해보면, 해당 마을을 기준으로 어디서 두니발 박사가 왔을지를 따져주면 됩니다.</p></li>
<li><p>현재 위치의 마을을 k번 마을이라고 합시다. 그리고 우리가 구하려는 n번째 날 k번 마을에 두니발 박사가 있을 확률을 P(n, k)라고 합시다. k번 마을에 연결된 마을 하나를 m번 마을(Vm이라 하겠습니다)이라 하면, 이 m번 마을 Vm에 대해서 각각 그 곳에서 두니발 박사가 왔을 확률을 구해 더해주면 됩니다.</p></li>
<li>두니발 박사가 전날 Vm 마을에 있을 확률은 P(n-1, Vm)입니다. 그리고 Vm 마을에서 현재의 k번 마을을 선택할 확률은, 1/(Vm의 차수)가 됩니다. 따라서 점화식은 다음과 같이 세울 수 있습니다. 합을 구한다는 것은 k번 마을에 직접 연결된 마을만을 기준으로 합니다.<br />
</li>
</ul>
<pre class="markdown"><code>P(n, k) = ( 1/(Vm의 차수) * P(n-1, Vm) )의 합</code></pre>
<ul>
<li>기저 사례는 지난 날짜 days가 1일 경우, village가 prison과 직접 연결되어 있을 경우는 1/(prison의 차수)를 반환해주고, 나머지는 연결되있지 않아서 이동할 수 없었을 것이므로 0을 반환해주면 됩니다.</li>
</ul>
<h3 id="코드">코드</h3>
<hr />
<details>
<p><summary>코드 보기</summary></p>
<p><a href="https://github.com/wbluke/Algorithm_PS/blob/master/src/CH08_3/NUMB3RS.java">Github Link</a></p>
<pre class="java"><code>/* NUMB3RS.java */

import java.util.*;

public class NUMB3RS {

    private int[][] villageArr;
    private double[][] cache;
    private int[] roadsOnVillage;
    private int prison; // position of prison
    private int villages; // num of villages

    public double probCatchDunibal(int days, int village) {
        // base case
        if (days == 1) {
            if (villageArr[prison][village] == 0) return 0;
            return 1.0 / roadsOnVillage[prison];
        }

        // memoization
        if (cache[days][village] != -1) return cache[days][village];

        double ret = 0;
        for (int i = 0; i &lt; villages; i++) {
            if (villageArr[village][i] == 1)
                ret += (1.0 / roadsOnVillage[i]) * probCatchDunibal(days - 1, i);
        }

        return cache[days][village] = ret;
    }

    public static void main(String[] args) {
        NUMB3RS numb3RS = new NUMB3RS();
        Scanner scan = new Scanner(System.in);

        numb3RS.villageArr = new int[51][51];
        numb3RS.cache = new double[101][51];
        numb3RS.roadsOnVillage = new int[51];

        int loop = scan.nextInt();
        while(loop-- &gt; 0) {
            // cache init
            for(double[] arr : numb3RS.cache) {
                Arrays.fill(arr, -1);
            }
            Arrays.fill(numb3RS.roadsOnVillage, 0);

            numb3RS.villages = scan.nextInt();
            int days = scan.nextInt();
            numb3RS.prison = scan.nextInt();
            for (int i = 0; i &lt; numb3RS.villages; i++) {
                for (int j = 0; j &lt; numb3RS.villages; j++) {
                    int temp = scan.nextInt();
                    numb3RS.villageArr[i][j] = temp;
                    numb3RS.roadsOnVillage[i] += temp;
                }
            }

            int targets = scan.nextInt();
            int[] target = new int[targets];
            for (int i = 0; i &lt; targets; i++) {
                target[i] = scan.nextInt();
            }

            for(int village : target) {
                System.out.println(numb3RS.probCatchDunibal(days, village));
            }
        }
    }
}</code></pre>
</details>
