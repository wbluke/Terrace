<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"><link rel="icon" href="/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/styles/default.min.css"><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><title> | Luke's Note</title><link href="/css/app.2ad29d68.css" rel="preload" as="style"><link href="/css/chunk-vendors.bad0137f.css" rel="preload" as="style"><link href="/js/app.b8edd235.js" rel="preload" as="script"><link href="/js/chunk-vendors.708a92f7.js" rel="preload" as="script"><link href="/css/chunk-vendors.bad0137f.css" rel="stylesheet"><link href="/css/app.2ad29d68.css" rel="stylesheet"><meta charset="utf-8" data-vue-meta="true"><meta property="og:image" content="https://wbluke.com/img/about.f9a09115.jpeg" data-vmid="og:image" data-vue-meta="true"><meta property="og:title" content="8-4.LIS | Luke's Note" data-vmid="og:title" data-vue-meta="true"><meta property="og:description" content="Thank you for reading my article 🦊" data-vmid="og:description" data-vue-meta="true"></head><body><noscript><strong>We're sorry but home doesn't work properly without JavaScript enabled. Please enable it to continue.</strong></noscript><div id="app"><div id="site-title"><a href="/" class="page_title router-link-active"><h1><img id="site-logo" src="/img/favicon.4eb5b8a7.png" width="24" height="24">
        Luke's Note
      </h1></a></div><div class="menu effect"><ul><li><a href="/" class="router-link-active">About</a></li><li><a href="/blog/" class="router-link-active">Blog</a></li><li><a href="/insight/" class="">Insight</a></li></ul></div><p><div data-v-210f1d5a="" id="blog"><div data-v-210f1d5a="" id="blog-contents"><article data-v-210f1d5a=""><div data-v-210f1d5a="" class="inner-title-container"><h1 data-v-210f1d5a=""><a data-v-210f1d5a="" href="http://wbluke.com/blog/2019/01/29/8-4.LIS/" id="inner-title">[알고리즘] 8-4. LIS (Longest Increasing Sequence)</a></h1><p data-v-210f1d5a="" class="meta">2019 / 01 / 29</p></div><div data-v-210f1d5a="" id="article-content"><h1 id="알고리즘-8-4.-lis-longest-increasing-sequence" style="display: none;">[알고리즘] 8-4. LIS (Longest Increasing Sequence)</h1>
<h3 id="문제">문제</h3>
<hr>
<details>
<p></p><summary>문제 보기</summary><p></p>
<p><a href="https://algospot.com/judge/problem/read/LIS">Algospot Link : LIS</a></p>
<p><strong>문제</strong></p>
<p>어떤 정수 수열에서 0개 이상의 숫자를 지우면 이 수열의 부분 수열(subsequence)을 얻을 수 있다. 예를 들어 <code class="hljs">10 7 4 9</code> 의 부분 수열에는 <code class="hljs">7 4 9</code>, <code class="hljs">10 4</code>, <code class="hljs">10 9</code> 등이 있다. 단, <code class="hljs">10 4 7</code>은 원래 수열의 순서와 다르므로 <code class="hljs">10 7 4 9</code> 의 부분 수열이 아니다.</p>
<p>어떤 부분 수열이 순증가할 때 이 부분 수열을 증가 부분 수열(increasing subsequence)이라고 한다. 주어진 수열의 증가 부분 수열 중 가장 긴 것의 길이를 계산하는 프로그램을 작성하라.</p>
<p>어떤 수열의 각 수가 이전의 수보다 클 때, 이 수열을 순증가 한다고 한다.</p>
<p><strong>입력</strong></p>
<p>입력의 첫 줄에는 테스트 케이스의 수 <code class="hljs">C (&lt;= 50)</code> 가 주어진다. 각 테스트 케이스의 첫 줄에는 수열에 포함된 원소의 수 <code class="hljs">N (&lt;= 500)</code> 이 주어진다. 그 다음 줄에 수열이 N개의 정수가 주어진다. 각 정수는 1 이상 100,000 이하의 자연수이다.</p>
<p><strong>출력</strong></p>
<p>각 테스트케이스마다 한 줄씩, 주어진 수열의 가장 긴 증가 부분 수열의 길이를 출력한다.</p>
<p><strong>예제 입력</strong></p>
<pre><code class="hljs">3
4
1 2 3 4
8
5 4 3 2 1 6 7 8 
8
5 6 7 8 1 2 3 4</code></pre>
<p><strong>예제 출력</strong></p>
<pre><code class="hljs">4
4
4</code></pre>
</details>
<h3 id="정리">정리</h3>
<hr>
<ul>
<li><p>최대 증가 부분 수열(LIS : Longest Increasing Sequence)이라 불리는 이 문제는 유명한 동적 계획법 연습문제 중 하나입니다.</p></li>
<li><p>단순하게 완전 탐색으로 풀려고 생각해보면, 주어진 수열에서 해당 인덱스 이후로 큰 수들만 모아 탐색을 하는 방법을 떠올릴 수 있습니다. 하지만 이 방법은 함수를 구현하는 과정에서 입력을 정수가 아닌 정수 배열로 받아야하기 때문에, 메모이제이션을 적용하기가 어려움을 알 수 있습니다.</p></li>
<li>동적 계획법을 적용하기 위해 부분문제의 정의를 바꿔봅시다. 다음과 같이 말이죠.<br>
</li>
</ul>
<pre><code class="hljs cpp">findLIS(<span class="hljs-keyword">int</span> start) : S[start]에서 시작하는 부분 증가 수열 중 최대의 길이</code></pre>
<ul>
<li><p>위 부분문제를 바탕으로 findLIS()를 메모이제이션을 적용하여 구현합니다. 기저 사례는 <code class="hljs">현재 위치에서 내 뒤로 큰 수가 없는 경우 : 자기자신</code>이므로 기본 return값은 1로 처리합니다. 이후 반복문 안에서 최장길이를 1씩 증가시켜주면서 재귀호출합니다.</p></li>
<li><p>여기서 생각해보아야 할 이슈가 생깁니다. 처음 <code class="hljs">findLIS()</code>를 호출할 때, 시작위치를 따로 찾아서 지정해주어야 모든 case를 탐색할 수 있게 됩니다.<br>
여기서 약간만 머리를 써서, 주어진 배열 앞에 -1인 인덱스를 갖는 정수 자리 한 칸이 있다고 상상해봅시다. 그 칸의 수는 모든 수들보다 작다고 가정합니다. (실제로 처리할 때는 반복문에서 <code class="hljs">start == -1</code>인 경우로 처리하면 됩니다.)<br>
그렇게 비교하면 해당 칸을 기준으로 뒤쪽에 있는 원래 배열의 모든 경우를 탐색할 수 있게 됩니다.<br>
가상으로 배열을 한 칸 늘렸으므로, cache배열도 1 증가시켜서 잡아줍니다.</p></li>
<li><p>이 코드는 총 O(n)개의 부분문제를 갖고, O(n) 시간의 반복문을 순회하므로 총 O(n^2)의 시간 복잡도를 가집니다. 그러나 더 빨리 O(n*logn)시간에 풀 수 있는 LIS풀이법이 존재합니다.</p></li>
<li><p>먼저 비어있는 수열 A를 하나 생성합니다. 그리고 주어진 수열 S를 하나씩 보면서, A에서 그 수보다 크거나 같은 값 중 가장 작은 값의 위치에 해당 정수를 덮어 씌웁니다. 해당 수가 가장 큰 수라면 끝 쪽 빈자리에 새로 추가하면서 LIS의 길이를 1 증가시켜줍니다.<br>
만들어져가는 A는 순증가하는 상태기 때문에, 해당 자리를 찾을 때 O(logn)의 시간 복잡도를 가지는 이진탐색을 사용할 수 있습니다.</p></li>
</ul>
<h3 id="코드">코드</h3>
<hr>
<ul>
<li>O(n^2)의 시간이 걸리는 LIS 코드</li>
</ul>
<details>
<p></p><summary>코드 보기</summary><p></p>
<p><a href="https://github.com/wbluke/Algorithm_PS/blob/master/CH08_2/CH08_2/LIS.cpp">Github Link</a></p>
<pre class="cpp"><code class="hljs"><span class="hljs-comment">/* LIS.cpp */</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">int</span> S[<span class="hljs-number">500</span>], cache[<span class="hljs-number">501</span>], N;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span></span>{
    <span class="hljs-comment">//memoization</span>
    <span class="hljs-keyword">int</span> &amp;ret = cache[start + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ret;
    
    ret = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> next = start + <span class="hljs-number">1</span>; next &lt;N; ++next){
        <span class="hljs-keyword">if</span>(start == <span class="hljs-number">-1</span> || S[start] &lt; S[next]){
            ret = max(ret, findLIS(next) + <span class="hljs-number">1</span>);
        }
    }
    <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
    
    <span class="hljs-keyword">int</span> num;
    <span class="hljs-built_in">cin</span> &gt;&gt; num;
    
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>; a&lt;num; ++a){
        <span class="hljs-built_in">cin</span> &gt;&gt; N;
        <span class="hljs-built_in">memset</span>(cache, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(cache));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;N; ++i){
            <span class="hljs-built_in">cin</span> &gt;&gt; S[i];
        }
        
        <span class="hljs-comment">//search all indices</span>
        <span class="hljs-keyword">int</span> start = <span class="hljs-number">-1</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; findLIS(start) - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
    
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
</details>
<ul>
<li>O(n*logn)의 시간이 걸리는 LIS 코드</li>
</ul>
<details>
<p></p><summary>코드 보기</summary><p></p>
<pre class="cpp"><code class="hljs"><span class="hljs-keyword">int</span> A[<span class="hljs-number">500</span>]; <span class="hljs-comment">// LIS를 만들어 갈 비어있는 배열</span>
<span class="hljs-keyword">int</span> lis; <span class="hljs-comment">// LIS 길이</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">findLIS2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-comment">//A가 비어있거나 모든 A의 수보다 크다면</span>
    <span class="hljs-keyword">if</span> (lis == <span class="hljs-number">0</span> || (lis &gt; <span class="hljs-number">0</span> &amp;&amp; num &gt;= A[lis - <span class="hljs-number">1</span>])) {
        A[lis++] = num;
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">//삽입할 위치를 이진탐색으로 찾는다</span>
    <span class="hljs-keyword">int</span> front = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> rear = lis - <span class="hljs-number">1</span>;

    <span class="hljs-keyword">while</span> (front &lt;= rear) {
        <span class="hljs-keyword">int</span> mid = (front + rear) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span> (num &gt; A[mid])
            front = mid + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span>
            rear = mid - <span class="hljs-number">1</span>;
    }
    A[rear + <span class="hljs-number">1</span>] = num;
}</code></pre>
</details>
</div></article><hr data-v-210f1d5a=""></div></div></p></div><script src="/js/chunk-vendors.708a92f7.js"></script><script src="/js/app.b8edd235.js"></script></body></html>