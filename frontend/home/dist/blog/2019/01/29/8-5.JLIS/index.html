<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"><link rel="icon" href="/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/styles/default.min.css"><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><title> | Luke's Note</title><link href="/css/app.408a12d0.css" rel="preload" as="style"><link href="/css/chunk-vendors.bad0137f.css" rel="preload" as="style"><link href="/js/app.4c6f659c.js" rel="preload" as="script"><link href="/js/chunk-vendors.708a92f7.js" rel="preload" as="script"><link href="/css/chunk-vendors.bad0137f.css" rel="stylesheet"><link href="/css/app.408a12d0.css" rel="stylesheet"><meta charset="utf-8" data-vue-meta="true"><meta property="og:image" content="https://wbluke.com/img/about.f9a09115.jpeg" data-vmid="og:image" data-vue-meta="true"><meta property="og:title" content="8-5.JLIS | Luke's Note" data-vmid="og:title" data-vue-meta="true"><meta property="og:description" content="Thank you for reading my article 🦊" data-vmid="og:description" data-vue-meta="true"></head><body><noscript></noscript><div id="app"><div id="site-title"><a href="/" class="page_title router-link-active"><h1><img id="site-logo" src="/img/favicon.4eb5b8a7.png" width="24" height="24">
        Luke's Note
      </h1></a></div><div class="menu effect"><ul><li><a href="/" class="router-link-active">About</a></li><li><a href="/blog/" class="router-link-active">Blog</a></li><li><a href="/insight/" class="">Insight</a></li></ul></div><p><div data-v-13a9dbde="" id="blog"><div data-v-13a9dbde="" id="blog-contents"><article data-v-13a9dbde=""><div data-v-13a9dbde="" class="inner-title-container"><h1 data-v-13a9dbde=""><a data-v-13a9dbde="" href="http://wbluke.com/blog/2019/01/29/8-5.JLIS/" id="inner-title">[알고리즘] 8-5. JLIS (합친 LIS)</a></h1><p data-v-13a9dbde="" class="meta">2019. 01. 29. </p></div><div data-v-13a9dbde="" id="article-content"><h1 id="알고리즘-8-5.-jlis-합친-lis" style="display: none;">[알고리즘] 8-5. JLIS (합친 LIS)</h1>
<h3 id="문제">문제</h3>
<hr>
<details>
<p></p><summary>문제 보기</summary><p></p>
<p><a href="https://algospot.com/judge/problem/read/JLIS">Algospot Link : JLIS</a></p>
<p><strong>문제</strong></p>
<p>어떤 수열에서 0개 이상의 숫자를 지운 결과를 원 수열의 부분 수열이라고 부릅니다. 예를 들어 <code class="hljs bash"><span class="hljs-string">'4 7 6'</span></code>은 <code class="hljs bash"><span class="hljs-string">'4 3 7 6 9'</span></code>의 부분 수열입니다. 중복된 숫자가 없고 오름 차순으로 정렬되어 있는 부분 수열들을 가리켜 증가 부분 수열이라고 부르지요. 예를 들어 <code class="hljs bash"><span class="hljs-string">'3 6 9'</span></code>는 앞의 수열의 증가 부분 수열입니다.</p>
<p>두 개의 정수 수열 A 와 B 에서 각각 증가 부분 수열을 얻은 뒤 이들을 크기 순서대로 합친 것을 합친 증가 부분 수열이라고 부르기로 합시다. 이 중 가장 긴 수열을 합친 <code class="hljs">LIS(JLIS, Joined Longest Increasing Subsequence)</code>이라고 부릅시다. 예를 들어 <code class="hljs bash"><span class="hljs-string">'1 3 4 7 9'</span></code> 은 <code class="hljs bash"><span class="hljs-string">'1 9 4'</span></code> 와 <code class="hljs bash"><span class="hljs-string">'3 4 7'</span></code> 의 JLIS입니다. <code class="hljs bash"><span class="hljs-string">'1 9'</span></code> 와 <code class="hljs bash"><span class="hljs-string">'3 4 7'</span></code> 을 합쳐 <code class="hljs bash"><span class="hljs-string">'1 3 4 7 9'</span></code>를 얻을 수 있기 때문이지요.</p>
<p>A 와 B 가 주어질 때, JLIS의 길이를 계산하는 프로그램을 작성하세요.</p>
<p><strong>입력</strong></p>
<p>입력의 첫 줄에는 테스트 케이스의 수 <code class="hljs">c ( 1 &lt;= c &lt;= 50 )</code> 가 주어집니다. 각 테스트 케이스의 첫 줄에는 A 와 B 의 길이 <code class="hljs">n</code> 과 <code class="hljs">m</code> 이 주어집니다 <code class="hljs">(1 &lt;= n,m &lt;= 100)</code>. 다음 줄에는 n 개의 정수로 A 의 원소들이, 그 다음 줄에는 m 개의 정수로 B 의 원소들이 주어집니다. 모든 원소들은 32비트 부호 있는 정수에 저장할 수 있습니다.</p>
<p><strong>출력</strong></p>
<p>각 테스트 케이스마다 한 줄에, JLIS 의 길이를 출력합니다.</p>
<p><strong>예제 입력</strong></p>
<pre><code class="hljs">3
3 3
1 2 4
3 4 7
3 3
1 2 3
4 5 6
5 3
10 20 30 1 2
10 20 30</code></pre>
<p><strong>예제 출력</strong></p>
<pre><code class="hljs">5
6
5</code></pre>
</details>
<h3 id="정리">정리</h3>
<hr>
<ul>
<li><p>이전 문제였던 LIS의 확장판입니다. 단순하게 생각하면 ’각각 두 수열에서 LIS를 구한 다음에 합치면 되지 않을까?’라고 볼 수도 있겠지만, 세 번째 예제 입력인 <code class="hljs">10 20 30 1 2</code>와 <code class="hljs">10 20 30</code>을 볼 때 불가능한 방법이라는 것을 알 수 있습니다. 각각 LIS를 구하면 둘 다 <code class="hljs">10 20 30</code>일텐데, 실제 JLIS는 <code class="hljs">1 2 10 20 30</code>일테니까요.</p></li>
<li>LIS의 풀이법에서 확장시켜봅시다. 이전에 풀었던 LIS에서 정의한 부분문제는 다음과 같았습니다.<br>
</li>
</ul>
<pre><code class="hljs cpp">findLIS(<span class="hljs-keyword">int</span> start) : S[start]에서 시작하는 부분 증가 수열 중 최대의 길이</code></pre>
<ul>
<li>JLIS에서는 수열이 두 개가 되었으니, 입력도 두 개를 받아야겠네요.<br>
</li>
</ul>
<pre><code class="hljs css"><span class="hljs-selector-tag">findJLIS</span>(<span class="hljs-selector-tag">indexA</span>, <span class="hljs-selector-tag">indexB</span>) : <span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[indexA]</span>와 <span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[indexB]</span>에서 시작하는 합친 부분 증가 수열 중 최대의 길이</code></pre>
<ul>
<li><p>여담이지만, 아래 코드에서는 수열을 M과 N으로 잡았다가 혼자 왕창 꼬여서 꽤나 고생했습니다. 발음이 비슷해서라는 변명을 해봅니다… <del>그냥 A B로 할걸</del></p></li>
<li><p>두 수의 순서는 지정하지 않았기 때문에, <code class="hljs css"><span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[indexA]</span></code>와 <code class="hljs css"><span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[indexB]</span></code> 중 더 작은 쪽이 앞에 온다고 합시다. 그러면 이 JLIS의 다음 숫자는 <code class="hljs css"><span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[indexA + 1]</span></code> 이후 혹은 <code class="hljs css"><span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[indexB + 1]</span></code> 이후의 수열 중에서 <code class="hljs css"><span class="hljs-selector-tag">max</span>(<span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[indexA]</span>, <span class="hljs-selector-tag">B</span><span class="hljs-selector-attr">[indexB]</span>)</code> 보다 큰 수 중 하나가 됩니다.<br>
그리고 <code class="hljs css"><span class="hljs-selector-tag">A</span><span class="hljs-selector-attr">[nextA]</span></code>를 다음 숫자로 선택했을 경우에 JLIS의 최대 길이는 <code class="hljs">1 + findJLIS(nextA, indexB)</code>가 됩니다.</p></li>
<li><p>LIS에서처럼 모든 인덱스에서 JLIS를 찾아보기 위해 시작지점의 인덱스를 -1로 잡고, cache도 한 칸씩 늘려서 잡아줍니다.</p></li>
<li><p>또, 이 문제에서 생각해보아야 할 이슈가 한 가지 더 있습니다. 문제 입력의 범위가 <code class="hljs">32비트 부호 있는 모든 정수</code>이기 때문에, 입력에 등장하지 않는 작은 값을 쓰려면 64비트 정수를 써야만 합니다. 해당 상수의 타입을 <code class="hljs cpp"><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span></code>으로 잡아줍니다.</p></li>
</ul>
<h3 id="코드">코드</h3>
<hr>
<details>
<p></p><summary>코드 보기</summary><p></p>
<p><a href="https://github.com/wbluke/Algorithm_PS/blob/master/CH08_2/CH08_2/JLIS.cpp">Github Link</a></p>
<pre class="cpp"><code class="hljs"><span class="hljs-comment">/* LIS.cpp */</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">int</span> m, n, M[<span class="hljs-number">100</span>], N[<span class="hljs-number">100</span>];
<span class="hljs-keyword">int</span> cache[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];
<span class="hljs-keyword">const</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> NEGINF = numeric_limits&lt;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>&gt;::min();

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findJLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> indexM, <span class="hljs-keyword">int</span> indexN)</span></span>{
    <span class="hljs-comment">//memoization</span>
    <span class="hljs-keyword">int</span> &amp;ret = cache[indexM + <span class="hljs-number">1</span>][indexN + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">if</span>(ret != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ret;
    
    ret = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> a = (indexM == <span class="hljs-number">-1</span> ? NEGINF : M[indexM]);
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> b = (indexN == <span class="hljs-number">-1</span> ? NEGINF : N[indexN]);
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> maxElement = max(a, b);
    
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> nextM = indexM + <span class="hljs-number">1</span>; nextM &lt; m; ++nextM){
        <span class="hljs-keyword">if</span>(maxElement &lt; M[nextM])
            ret = max(ret, findJLIS(nextM, indexN) + <span class="hljs-number">1</span>);
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> nextN = indexN + <span class="hljs-number">1</span>; nextN &lt; n; ++nextN){
        <span class="hljs-keyword">if</span>(maxElement &lt; N[nextN])
            ret = max(ret, findJLIS(indexM, nextN) + <span class="hljs-number">1</span>);
    }
    
    <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
    <span class="hljs-keyword">int</span> num;
    <span class="hljs-built_in">cin</span> &gt;&gt; num;
    
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a=<span class="hljs-number">0</span>; a&lt;num; ++a){
        <span class="hljs-built_in">cin</span> &gt;&gt; m &gt;&gt; n;
        
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;m; ++i){
            <span class="hljs-built_in">cin</span> &gt;&gt; M[i];
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; ++i){
            <span class="hljs-built_in">cin</span> &gt;&gt; N[i];
        }
        <span class="hljs-built_in">memset</span>(cache, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(cache));
        <span class="hljs-built_in">cout</span> &lt;&lt; findJLIS(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre>
</details>
<h3 id="문법">문법</h3>
<hr>
<ul>
<li><code class="hljs bash">const <span class="hljs-built_in">type</span> NEGINF = numeric_limits::min();</code> : 해당 type의 최소치(max : 최대치)를 얻을 수 있다.</li>
</ul>
</div></article><hr data-v-13a9dbde=""></div></div></p></div><script src="/js/chunk-vendors.708a92f7.js"></script><script src="/js/app.4c6f659c.js"></script></body></html>