<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"><link rel="icon" href="/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/styles/default.min.css"><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><title> | Luke's Note</title><link href="/css/app.17e32a07.css" rel="preload" as="style"><link href="/css/chunk-vendors.bad0137f.css" rel="preload" as="style"><link href="/js/app.756a0133.js" rel="preload" as="script"><link href="/js/chunk-vendors.319ec894.js" rel="preload" as="script"><link href="/css/chunk-vendors.bad0137f.css" rel="stylesheet"><link href="/css/app.17e32a07.css" rel="stylesheet"><meta charset="utf-8" data-vue-meta="true"><meta property="og:image" content="https://wbluke.com/img/about.f9a09115.jpeg" data-vmid="og:image" data-vue-meta="true"><meta property="og:title" content="8-12.POLY | Luke's Note" data-vmid="og:title" data-vue-meta="true"><meta property="og:description" content="Thank you for reading my article 🦊" data-vmid="og:description" data-vue-meta="true"><script type="text/javascript" async="">var disqus_shortname  = "wbluke-com";
var disqus_title      = "8-12.POLY";
var disqus_identifier = "/2019/02/18/8-12.POLY/";
var disqus_url        = "http://wbluke.com/blog/2019/02/18/8-12.POLY/";
</script><script type="text/javascript" async="" src="//wbluke-com.disqus.com/embed.js"></script><link rel="preload" as="style" href="https://c.disquscdn.com/next/embed/styles/lounge.9974049bf7b0591e5d4f055cb67f3ee3.css"><link rel="preload" as="script" href="https://c.disquscdn.com/next/embed/common.bundle.880980e048a2432334f13013030456ac.js"><link rel="preload" as="script" href="https://c.disquscdn.com/next/embed/lounge.bundle.7ca5005d1897180d07d928e89d2628be.js"><link rel="preload" as="script" href="https://disqus.com/next/config.js"></head><body><noscript></noscript><div id="app"><div id="site-title"><a href="/" class="page_title router-link-active"><h1><img id="site-logo" src="/img/favicon.4eb5b8a7.png" width="24" height="24">
        Luke's Note
      </h1></a></div><div class="menu effect"><ul><li><a href="/" class="router-link-active">About</a></li><li><a href="/blog/" class="router-link-active">Blog</a></li><li><a href="/insight/" class="">Insight</a></li></ul></div><p><div data-v-476fdc0b="" id="blog"><div data-v-476fdc0b="" id="blog-contents"><article data-v-476fdc0b=""><div data-v-476fdc0b="" class="inner-title-container"><h1 data-v-476fdc0b=""><a data-v-476fdc0b="" href="http://wbluke.com/blog/2019/02/18/8-12.POLY/" id="inner-title">[알고리즘] 8-12. POLY (폴리오미노)</a></h1><p data-v-476fdc0b="" class="meta">2019. 02. 18. </p></div><div data-v-476fdc0b="" id="article-content"><h1 id="알고리즘-8-12.-poly-폴리오미노" style="display: none;">[알고리즘] 8-12. POLY (폴리오미노)</h1>
<h3 id="문제">문제</h3>
<hr>
<details>
<p></p><summary>문제 보기</summary><p></p>
<p><a href="https://algospot.com/judge/problem/read/POLY">Algospot Link : POLY</a></p>
<p><strong>문제</strong></p>
<p>정사각형들의 변들을 서로 완전하게 붙여 만든 도형들을 폴리오미노(Polyomino)라고 부릅니다. n개의 정사각형으로 구성된 폴리오미노들을 만들려고하는데, 이 중 세로로 단조(monotone)인 폴리오미노의 수가 몇 개나 되는지 세고 싶습니다. 세로로 단조라는 말은 어떤 가로줄도 폴리오미노를 두 번 이상 교차하지 않는다는 뜻입니다.</p>
<p><img src="http://algospot.com/media/judge-attachments/1f80fe48fcd9234b6a70d2bf940c934c/poly.png" width="500"></p>
<p>예를 들어 그림 (a)는 정상적인 세로 단조 폴리오미노입니다. 그러나 (b)는 점선이 폴리오미노를 두 번 교차하기 때문에 세로 단조 폴리오미노가 아닙니다. (c)는 맨 오른쪽 아래 있는 정사각형이 다른 정사각형과 변을 완전히 맞대고 있지 않기 때문에 폴리오미노가 아닙니다.</p>
<p>n개의 정사각형으로 구성된 세로 단조 폴리오미노의 개수를 세는 프로그램을 작성하세요.</p>
<p><strong>입력</strong></p>
<p>입력의 첫 줄에는 테스트 케이스의 수 <code class="hljs">C (1≤C≤50)</code>가 주어집니다. 그 후 각 줄에 폴리오미노를 구성할 정사각형의 수 <code class="hljs">n (1≤n≤100)</code>이 주어집니다.</p>
<p><strong>출력</strong></p>
<p>각 테스트 케이스마다, n개의 정사각형으로 구성된 세로 단조 폴리오미노의 수를 출력합니다. 폴리오미노의 수가 <code class="hljs">10,000,000</code> 이상일 경우 <code class="hljs">10,000,000</code>으로 나눈 나머지를 출력합니다.</p>
<p><strong>예제 입력</strong></p>
<pre><code class="hljs">3
2
4
92</code></pre>
<p><strong>예제 출력</strong></p>
<pre><code class="hljs">2
19
4841817</code></pre>
</details>
<h3 id="정리">정리</h3>
<hr>
<ul>
<li><p>동적 계획법을 적용하기 위해 부분조각의 정의를 잘 설정해주어야 하는 문제입니다. 저는 처음에 어떤 폴리오미노에서 맨 위 또는 맨 아래로 정사각형 하나를 붙이는 방법에 대해서 고민했었는데, DP를 적용할 수 있는 구조가 아니어서 풀지 못했습니다.</p></li>
<li><p>일단 문제해결을 위한 countMonoPoly()를 구현하기 위해서 인자로 폴리오미노의 개수 squares를 들고 갑니다. 여기서 한 가지 인자가 더 필요합니다. 부분문제의 정의를 다음과 같이 설정합니다.</p></li>
</ul>
<pre class="markdown"><code class="hljs">countMonoPoly(int n, int first) : n개의 조각, 그리고 첫 줄이 first개인 폴리오미노의 개수</code></pre>
<ul>
<li><p>폴리오미노의 개수는 첫 줄과 그 다음 재귀호출한 폴리오미노의 첫 줄(즉, 두 번째 줄)의 개수에 의해 결정됩니다. 첫 줄이 a개, 재귀 호출한 폴리오미노의 첫 번째 줄을 b개라고 할 때, 재귀 호출한 조각을 첫 줄 뒤에 붙이는 방법의 가짓수는 (a + b - 1)가지 입니다. 따라서 반복문 안에서 각 가짓수를 곱하면서, 재귀 호출 조각의 첫 줄의 개수가 달라지게 재귀 호출 해주면 됩니다.</p></li>
<li><p>기저 사례는 squares와 firstLine의 개수가 같아졌을 때 방법의 가짓수가 하나이므로 1을 반환해주면 됩니다.</p></li>
</ul>
<h3 id="코드">코드</h3>
<hr>
<details>
<p></p><summary>코드 보기</summary><p></p>
<p><a href="https://github.com/wbluke/Algorithm_PS/blob/master/src/CH08_3/POLY.java">Github Link</a></p>
<pre class="java"><code class="hljs"><span class="hljs-comment">/* POLY.java */</span>

<span class="hljs-keyword">import</span> java.util.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">POLY</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MOD = <span class="hljs-number">10</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] cache;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countMonoPoly</span><span class="hljs-params">(<span class="hljs-keyword">int</span> squares, <span class="hljs-keyword">int</span> firstLine)</span> </span>{
        <span class="hljs-comment">// base case</span>
        <span class="hljs-keyword">if</span> (squares == firstLine) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;

        <span class="hljs-comment">// memoization</span>
        <span class="hljs-keyword">if</span> (cache[squares][firstLine] != -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> cache[squares][firstLine];

        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= squares - firstLine; i++) {
            ret += (firstLine + i - <span class="hljs-number">1</span>) * countMonoPoly(squares - firstLine, i) % MOD;
        }
        <span class="hljs-keyword">return</span> cache[squares][firstLine] = ret % MOD;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        POLY poly = <span class="hljs-keyword">new</span> POLY();
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);

        poly.cache = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];

        <span class="hljs-keyword">int</span> loop = scan.nextInt();
        <span class="hljs-keyword">while</span>(loop-- &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-comment">// cache init</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] arr : poly.cache) {
                Arrays.fill(arr, -<span class="hljs-number">1</span>);
            }

            <span class="hljs-keyword">int</span> n = scan.nextInt();

            <span class="hljs-keyword">int</span> polyomino = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {
                polyomino += poly.countMonoPoly(n, i);
            }
            System.out.println(polyomino % MOD);
        }
    }
}</code></pre>
</details>
</div></article><hr data-v-476fdc0b=""><div data-v-476fdc0b="" id="disqus_thread"><iframe id="dsq-app7725" name="dsq-app7725" allowtransparency="true" frameborder="0" scrolling="no" tabindex="0" title="Disqus" width="100%" src="https://disqus.com/embed/comments/?base=default&amp;f=wbluke-com&amp;t_i=%2F2019%2F02%2F18%2F8-12.POLY%2F&amp;t_u=http%3A%2F%2Fwbluke.com%2Fblog%2F2019%2F02%2F18%2F8-12.POLY%2F&amp;t_e=8-12.POLY&amp;t_d=%0A%20%20%20%20%20%20%20%20Luke's%20Note%0A%20%20%20%20%20%20&amp;t_t=8-12.POLY&amp;s_o=default&amp;d_m=0#version=884cf41099cd8dae8f67a05fd265c45a" style="width: 1px !important; min-width: 100% !important; border: none !important; overflow: hidden !important; height: 0px !important;"></iframe></div></div></div></p></div><script src="/js/chunk-vendors.319ec894.js"></script><script src="/js/app.756a0133.js"></script><iframe style="display: none;"></iframe></body></html>