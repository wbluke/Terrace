<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"><link rel="icon" href="/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/styles/default.min.css"><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.8.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><title> | Luke's Note</title><link href="/css/app.77d36707.css" rel="preload" as="style"><link href="/css/chunk-vendors.bad0137f.css" rel="preload" as="style"><link href="/js/app.2f7f95e7.js" rel="preload" as="script"><link href="/js/chunk-vendors.319ec894.js" rel="preload" as="script"><link href="/css/chunk-vendors.bad0137f.css" rel="stylesheet"><link href="/css/app.77d36707.css" rel="stylesheet"><meta charset="utf-8" data-vue-meta="true"><meta property="og:image" content="https://wbluke.com/img/about.f9a09115.jpeg" data-vmid="og:image" data-vue-meta="true"><meta property="og:title" content="21-2.FORTRESS | Luke's Note" data-vmid="og:title" data-vue-meta="true"><meta property="og:description" content="Thank you for reading my article 🦊" data-vmid="og:description" data-vue-meta="true"><script type="text/javascript" async="">var disqus_shortname  = "wbluke-com";
var disqus_title      = "21-2.FORTRESS";
var disqus_identifier = "/2019/03/18/21-2.FORTRESS/";
var disqus_url        = "http://wbluke.com/blog/2019/03/18/21-2.FORTRESS/";
</script><script type="text/javascript" async="" src="//wbluke-com.disqus.com/embed.js"></script><link rel="preload" as="style" href="https://c.disquscdn.com/next/embed/styles/lounge.9974049bf7b0591e5d4f055cb67f3ee3.css"><link rel="preload" as="script" href="https://c.disquscdn.com/next/embed/common.bundle.880980e048a2432334f13013030456ac.js"><link rel="preload" as="script" href="https://c.disquscdn.com/next/embed/lounge.bundle.4180262f1aa52e0f0340aac9fc52a8d8.js"><link rel="preload" as="script" href="https://disqus.com/next/config.js"></head><body><noscript></noscript><div id="app"><div id="site-title"><a href="/" class="page_title router-link-active"><h1><img id="site-logo" src="/img/favicon.4eb5b8a7.png" width="24" height="24">
        Luke's Note
      </h1></a></div><div class="menu effect"><ul><li><a href="/" class="router-link-active">About</a></li><li><a href="/blog/" class="router-link-active">Blog</a></li><li><a href="/insight/" class="">Insight</a></li></ul></div><p><div data-v-8053fe28="" id="blog"><div data-v-8053fe28="" id="blog-contents"><article data-v-8053fe28=""><div data-v-8053fe28="" class="inner-title-container"><h1 data-v-8053fe28=""><a data-v-8053fe28="" href="http://wbluke.com/blog/2019/03/18/21-2.FORTRESS/" id="inner-title">[알고리즘] 21-2. FORTRESS (요새)</a></h1><p data-v-8053fe28="" class="meta">2019. 03. 18. </p></div><div data-v-8053fe28="" id="article-content"><h1 id="알고리즘-21-2.-fortress-요새" style="display: none;">[알고리즘] 21-2. FORTRESS (요새)</h1>
<h3 id="문제">문제</h3>
<hr>
<details>
<p></p><summary>문제 보기</summary><p></p>
<p><a href="https://algospot.com/judge/problem/read/FORTRESS">Algospot Link : FORTRESS</a></p>
<p><strong>문제</strong></p>
<p><img src="http://algospot.com/media/judge-attachments/6b98991b489acef77ed1b63dc31bc32f/castle.svg.png"></p>
<p>중세의 성과 요새들은 보안을 튼튼히 하면서도 더 넓은 영역을 보호하기 위해 여러 개의 성벽을 갖고 있었다고 하지요. 전세계에서 가장 편집증이 심한 영주가 지은 <code class="hljs">스트로고(Strawgoh)</code> 요새는 이의 극치를 보여줍니다. 이 요새는 그림과 같이 커다란 원형 외벽 내에 여러 개의 원형 성벽이 겹겹이 지어진 형태로 구성되어 있는데, 어떤 성벽에도 문이 없어서 성벽을 지나가려면 사다리를 타고 성벽을 오르내려야 합니다. 요새 내에서도 한 곳에서 다른 곳으로 이동하는 데 시간이 너무 오래 걸린다는 원성이 자자해지자, 영주는 요새 내에서 왕래가 불편한 곳들을 연결하는 터널을 만들기로 했습니다. 계획을 세우기 위해 요새 내에서 서로 왕래하기 위해 가장 성벽을 많이 넘어야 하는 두 지점을 찾으려고 합니다. 예를 들어 위 그림의 경우, 별표로 표시된 두 지점 간을 이동하기 위해서는 다섯 번이나 성벽을 넘어야 하지요.</p>
<p>성벽들의 정보가 주어질 때 가장 성벽을 많이 넘어야 하는 두 지점 간을 이동하기 위해 몇 번이나 성벽을 넘어야 하는지 계산하는 프로그램을 작성하세요.</p>
<p><strong>입력</strong></p>
<p>입력의 첫 줄에는 테스트 케이스의 수 <code class="hljs">C (1 &lt;= C &lt;= 100)</code> 가 주어집니다. 각 테스트 케이스의 첫 줄에는 성벽의 수 <code class="hljs">N (1 &lt;= N &lt;= 100)</code> 이 주어집니다. 그 후 N 줄에는 각 3개의 정수로 각 성벽의 위치와 크기에 대한 정보 x<sub>i</sub> , y<sub>i</sub> , r<sub>i</sub> 가 주어집니다. (0 &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 1000,1 &lt;= r<sub>i</sub> &lt;= 1000,0 &lt;= i&lt;N) 이 때 i 번 성벽은 (x<sub>i</sub>, y<sub>i</sub>) 를 중심으로 하는 반지름 r<sub>i</sub> 인 원형으로 설치되어 있습니다. 편의상 모든 성벽의 두께는 0이라고 가정하며, 입력에 주어지는 성벽들은 서로 겹치거나 닿지 않습니다. 입력에 주어지는 첫 번째 성벽은 외벽이며, 외벽은 입력에 주어지는 모든 다른 성벽을 포함합니다.</p>
<p><strong>출력</strong></p>
<p>각 테스트 케이스마다 한 줄에 두 지점 간 이동을 위해 최대 몇 번이나 성벽을 넘어야 하는지를 출력하세요.</p>
<p><strong>예제 입력</strong></p>
<pre><code class="hljs">2
3
5 5 15
5 5 10
5 5 5
8 
21 15 20 
15 15 10 
13 12 5 
12 12 3 
19 19 2 
30 24 5 
32 10 7 
32 9 4 </code></pre>
<p><strong>예제 출력</strong></p>
<pre><code class="hljs">2
5</code></pre>
</details>
<h3 id="정리">정리</h3>
<hr>
<p><a href="https://en.wikipedia.org/wiki/Hogwarts"><code class="hljs">스트로고(Strawgoh)</code> 요새의 뜻은…</a></p>
<ul>
<li><p>언뜻 보기에 트리와 별 관계없어 보이지만, 주어지는 성벽들이 서로 닿거나 겹치지 않는다는 조건을 생각하면 이 성벽들을 계층적 구조로 표현할 수 있음을 깨달을 수 있습니다. 트리 구조로 성벽들을 인식하게 되면, 한 노드에서 다른 노드로 가는 경로 중 가장 긴 경로를 찾는 문제라는 것을 알 수 있습니다. 그리고 쉽게 해결할 수 있을줄 알았는데 산 넘어 산이었습니다.</p></li>
<li><p>개인적으로 첫 번째로 시도한 방법은 leaf 노드에서 leaf 노드로 가는 최장 경로의 길이를 구하면 되지 않을까 하는 것이었습니다. 한참 구현하다가 가장 긴 leaf-leaf 경로가 항상 root 노드를 경유하는 것이 아니라는 것을 깨닫고 갈아엎었습니다. 심지어 트리 구조를 직접 구현하다가 꼬여서 (…)</p></li>
<li><p>성벽들을 트리 구조로 구현하게 해주는 핵심적인 메소드는 각 성벽들이 서로 <code class="hljs">직접적인</code> 부모-자식 관계인지 확인해주는 isChild() 메소드입니다. 여기서 <code class="hljs bash"><span class="hljs-string">'직접적인'</span></code>이라는 말이 상당히 중요한데, 계층구조에 상관없이 그냥 한 성벽이 다른 성벽을 포함하기만 하면 <code class="hljs bash"><span class="hljs-literal">true</span></code>로 알려주는 encloses() 메소드로 두 성벽 간에 또 다른 성벽이 없다는 것을 확인해야만 <code class="hljs bash"><span class="hljs-string">'직접적인'</span></code> 부모-자식 관계라는 것을 입증할 수 있습니다. 그래야 트리를 생성할 때 부모와 자식으로 노드를 연결해줄 수 있습니다. encloses() 구현에서도 주의할 점은 어떤 성벽이 부모고 어떤 성벽을 자식으로 해서 검사할 것인지, 즉 순서를 꼭 지켜주어야 트리 구조를 내가 제어할 수 있게 됩니다. 저는 <code class="hljs">fort1이 fort2를 포함하는가?</code> 로 구현했습니다.</p></li>
<li><p>isChild()를 구현했으면 이제 getTree()로 트리를 생성합니다. 어떤 root index를 기준으로 해당 노드가 어떤 자식을 가지고 있는지 isChild()로 검사해 준 후 자식이 맞으면 ArrayList에 추가해 줍니다. 추가할 때 트리 자체가 재귀적 구조이기 때문에 자식 노드도 트리가 될 수 있도록 getTree()를 재귀 호출하여 추가해 줍니다.</p></li>
<li><p>여기까지 트리를 만들고 나면 이제서야 문제를 풀 수 있는 준비가 끝난 것입니다. <del><em>어휴</em></del></p></li>
<li><p>height() 메소드에서 매개변수 노드를 기준으로 한 트리의 높이를 구합니다. 이도 마찬가지로 트리의 특성 상 재귀로 구하게 됩니다. 우리가 필요한 것은 전체 트리의 높이와 함께 최장 leaf-leaf 경로의 길이 두 가지이기 때문에, height를 구하면서 동시에 class field에 있는 longest에 최장 leaf-leaf 길이를 갱신시켜주면서 재귀호출 합니다. 현재 노드의 자식들의 height를 모두 구해서 배열에 넣어준 뒤에, 정렬을 해서 가장 큰 height와 그 다음 큰 height로 최장 leaf-leaf 경로의 길이를 구해줍니다. 구한 전체 트리의 높이와 longest의 길이는 solve() 메소드에서 비교하여 최종 답을 구해줍니다.</p></li>
</ul>
<h3 id="코드">코드</h3>
<hr>
<details>
<p></p><summary>코드 보기</summary><p></p>
<p><a href="https://github.com/wbluke/Algorithm_PS/blob/master/src/CH21/FORTRESS.java">Github Link</a></p>
<pre class="java"><code class="hljs"><span class="hljs-comment">/* FORTRESS.java */</span>

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Arrays;
<span class="hljs-keyword">import</span> java.util.Scanner;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FORTRESS</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] x;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] y;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] radius;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> fortresses;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> longest;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FORTRESS</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fortresses)</span> </span>{
        x = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[fortresses];
        y = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[fortresses];
        radius = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[fortresses];
        <span class="hljs-keyword">this</span>.fortresses = fortresses;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>{
        <span class="hljs-keyword">private</span> ArrayList&lt;TreeNode&gt; children = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">getTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rootIdx)</span> </span>{
        TreeNode ret = <span class="hljs-keyword">new</span> TreeNode();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fortresses; i++) {
            <span class="hljs-keyword">if</span> (isChild(rootIdx, i)) {
                ret.children.add(getTree(i));
            }
        }
        <span class="hljs-keyword">return</span> ret;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">encloses</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fort1, <span class="hljs-keyword">int</span> fort2)</span> </span>{
        <span class="hljs-keyword">double</span> distBetweenTwoCenters = Math.pow((x[fort1] - x[fort2]), <span class="hljs-number">2</span>) + Math.pow((y[fort1] - y[fort2]), <span class="hljs-number">2</span>);
        <span class="hljs-keyword">return</span> radius[fort1] &gt; radius[fort2] &amp;&amp; distBetweenTwoCenters &lt; Math.pow((radius[fort1] - radius[fort2]), <span class="hljs-number">2</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parent, <span class="hljs-keyword">int</span> child)</span> </span>{
        <span class="hljs-keyword">if</span> (!encloses(parent, child)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fortresses; i++) {
            <span class="hljs-keyword">if</span> (i != parent &amp;&amp; i != child &amp;&amp; encloses(parent, i) &amp;&amp; encloses(i, child)) {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">(TreeNode root)</span> </span>{
        <span class="hljs-keyword">if</span> (root.children.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

        <span class="hljs-keyword">int</span>[] heights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[root.children.size()];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; heights.length; i++) {
            heights[i] = height(root.children.get(i));
        }

        <span class="hljs-comment">// find the largest value and second largest value</span>
        Arrays.sort(heights);
        <span class="hljs-keyword">if</span> (heights.length &gt;= <span class="hljs-number">2</span>)
            longest = Math.max(longest, <span class="hljs-number">2</span> + heights[heights.length - <span class="hljs-number">2</span>] + heights[heights.length - <span class="hljs-number">1</span>]);

        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + heights[heights.length - <span class="hljs-number">1</span>];
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(TreeNode root)</span> </span>{
        longest = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> depth = height(root);

        <span class="hljs-keyword">return</span> Math.max(longest, depth);
    }

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
        Scanner scan = <span class="hljs-keyword">new</span> Scanner(System.in);

        <span class="hljs-keyword">int</span> loop = scan.nextInt();
        <span class="hljs-keyword">while</span>(loop-- &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">int</span> fortresses = scan.nextInt();

            FORTRESS fortress = <span class="hljs-keyword">new</span> FORTRESS(fortresses);

            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fortresses; i++) {
                fortress.x[i] = scan.nextInt();
                fortress.y[i] = scan.nextInt();
                fortress.radius[i] = scan.nextInt();
            }
            TreeNode root = fortress.getTree(<span class="hljs-number">0</span>);
            System.out.println(fortress.solve(root));
        }
    }
}
</code></pre>
</details>
</div></article><hr data-v-8053fe28=""><div data-v-8053fe28="" id="disqus_thread"><iframe id="dsq-app6681" name="dsq-app6681" allowtransparency="true" frameborder="0" scrolling="no" tabindex="0" title="Disqus" width="100%" src="https://disqus.com/embed/comments/?base=default&amp;f=wbluke-com&amp;t_i=%2F2019%2F03%2F18%2F21-2.FORTRESS%2F&amp;t_u=http%3A%2F%2Fwbluke.com%2Fblog%2F2019%2F03%2F18%2F21-2.FORTRESS%2F&amp;t_e=21-2.FORTRESS&amp;t_d=%0A%20%20%20%20%20%20%20%20Luke's%20Note%0A%20%20%20%20%20%20&amp;t_t=21-2.FORTRESS&amp;s_o=default&amp;d_m=0#version=3cd87e0f949a3290918feaf8a303966c" style="width: 1px !important; min-width: 100% !important; border: none !important; overflow: hidden !important; height: 0px !important;"></iframe></div></div></div></p></div><script src="/js/chunk-vendors.319ec894.js"></script><script src="/js/app.2f7f95e7.js"></script><iframe style="display: none;"></iframe></body></html>